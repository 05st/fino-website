"use strict";(self.webpackChunkfino_website=self.webpackChunkfino_website||[]).push([[315],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>k});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(t),m=r,k=c["".concat(s,".").concat(m)]||c[m]||u[m]||i;return t?a.createElement(k,l(l({ref:n},d),{},{components:t})):a.createElement(k,l({ref:n},d))}));function k(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7192:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:999},l="Syntax Reference",o={unversionedId:"syntax-reference",id:"syntax-reference",title:"Syntax Reference",description:"Fino's syntax is in a volatile state at the moment and this page is not updated frequently; it may be outdated. If it is, consider clicking Edit this page at the bottom and opening an issue or pull request.",source:"@site/docs/syntax-reference.md",sourceDirName:".",slug:"/syntax-reference",permalink:"/syntax-reference",draft:!1,editUrl:"https://github.com/05st/fino-website/tree/main/docs/syntax-reference.md",tags:[],version:"current",sidebarPosition:999,frontMatter:{sidebar_position:999},sidebar:"tutorialSidebar",previous:{title:"Expressions",permalink:"/basic-concepts/expressions"}},s={},p=[{value:"Declarations",id:"declarations",level:2},{value:"Data Declarations",id:"data-declarations",level:3},{value:"Type Alias Declarations",id:"type-alias-declarations",level:3},{value:"Fn Declarations",id:"fn-declarations",level:3},{value:"Let Declarations",id:"let-declarations",level:3},{value:"Trait Declarations",id:"trait-declarations",level:3},{value:"Impl Declarations",id:"impl-declarations",level:3},{value:"Expressions",id:"expressions",level:2},{value:"Operators",id:"operators",level:3},{value:"Variables",id:"variables",level:3},{value:"Literals",id:"literals",level:3},{value:"Function application",id:"function-application",level:3},{value:"Lambdas (anonymous functions)",id:"lambdas-anonymous-functions",level:3},{value:"Annotated Expressions",id:"annotated-expressions",level:3},{value:"Let Bindings",id:"let-bindings",level:3},{value:"If Expression",id:"if-expression",level:3},{value:"Match Expressions",id:"match-expressions",level:3},{value:"Do Notation",id:"do-notation",level:3},{value:"Mdo Notation",id:"mdo-notation",level:3},{value:"Patterns",id:"patterns",level:2},{value:"Miscellaneous",id:"miscellaneous",level:2},{value:"Imports",id:"imports",level:3},{value:"Exports",id:"exports",level:3},{value:"Extern Declarations",id:"extern-declarations",level:3}],d={toc:p},c="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"syntax-reference"},"Syntax Reference"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Fino's syntax is in a volatile state at the moment and this page is not updated frequently; it may be outdated. If it is, consider clicking ",(0,r.kt)("strong",{parentName:"p"},"Edit this page")," at the bottom and opening an issue or pull request.")),(0,r.kt)("p",null,"The programming language's current syntax and grammar is informally specified here. Arbitrary spaces are allowed between lexemes, excluding newlines. Newlines are only allowed where explicitly stated. Indentation may be required. An indentation is any whitespace 4 characters or more longer than the previous indentation."),(0,r.kt)("h2",{id:"declarations"},"Declarations"),(0,r.kt)("h3",{id:"data-declarations"},"Data Declarations"),(0,r.kt)("p",null,"For now, must all be on a single line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"data Maybe a = Nothing | Just a\n\ndata Either a b = Left a | Right b\n\ndata Nat = Zero | Succ Nat\n")),(0,r.kt)("h3",{id:"type-alias-declarations"},"Type Alias Declarations"),(0,r.kt)("p",null,"For now, must all be on a single line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"type Failable a = Either Error a\n\ntype Person = {name : str, age : i32}\n")),(0,r.kt)("h3",{id:"fn-declarations"},"Fn Declarations"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Fn")," declarations are desugared to ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," declarations with lambdas and match expressions in the parser."),(0,r.kt)("p",null,"Type annotation is optional. If type annotation is given, a newline must be present after the type annotation."),(0,r.kt)("p",null,"If a newline is present after the ",(0,r.kt)("inlineCode",{parentName:"p"},"fn <id> [: <type>]"),", then all cases must be indented and on a new line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'fn main : unit -> unit\n    () = println "Hello, World!"\n\nfn factorial\n    1 = 1\n    n = n * factorial (n - 1)\n\nfn id x = x\n')),(0,r.kt)("h3",{id:"let-declarations"},"Let Declarations"),(0,r.kt)("p",null,"Type annotation is optional."),(0,r.kt)("p",null,"For now, no newlines allowed before ",(0,r.kt)("inlineCode",{parentName:"p"},"="),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let x = y\n\nlet a: Type = expr\n")),(0,r.kt)("h3",{id:"trait-declarations"},"Trait Declarations"),(0,r.kt)("h3",{id:"impl-declarations"},"Impl Declarations"),(0,r.kt)("h2",{id:"expressions"},"Expressions"),(0,r.kt)("h3",{id:"operators"},"Operators"),(0,r.kt)("p",null,"Operators are desugared to regular function applications in the parser."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1 + 2\n~x\n92!\n")),(0,r.kt)("h3",{id:"variables"},"Variables"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"abc123\nQwe_'4\n\nsome.qualified.var\n")),(0,r.kt)("h3",{id:"literals"},"Literals"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"123\n123.456\ntrue\nfalse\n'a'\n'\\n'\n\"hello\\t\\n\"\n()\n")),(0,r.kt)("h3",{id:"function-application"},"Function application"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'print "hello"\nadd 1 2\nmap (add 1) listOfIntegers\ninput ()\n')),(0,r.kt)("h3",{id:"lambdas-anonymous-functions"},"Lambdas (anonymous functions)"),(0,r.kt)("p",null,"Lambdas with arity greater than one are desugared to multiple lambdas with arity one in the parser."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\\x -> y\n\\n m -> n + m\n\\a b c -> a (b c)\n")),(0,r.kt)("h3",{id:"annotated-expressions"},"Annotated Expressions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"expression : Type\n(3 + 4) : f32\n")),(0,r.kt)("h3",{id:"let-bindings"},"Let Bindings"),(0,r.kt)("p",null,"Newlines allowed before and after ",(0,r.kt)("inlineCode",{parentName:"p"},"in"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"let x = y in z\n\nlet var = 1 + 2\nin (+) 1 var\n\nlet a = expr in\nbody\n")),(0,r.kt)("h3",{id:"if-expression"},"If Expression"),(0,r.kt)("p",null,"Newlines allowed after ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),"."),(0,r.kt)("p",null,"Newlines allowed before and after ",(0,r.kt)("inlineCode",{parentName:"p"},"then")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"else"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"if c then a else b\n\nif c\nthen a\nelse b\n\nif\nc\nthen\na\nelse\nb\n\nif\n    c\nthen\n    a\nelse\n    b\n")),(0,r.kt)("h3",{id:"match-expressions"},"Match Expressions"),(0,r.kt)("p",null,"Indentation required after ",(0,r.kt)("inlineCode",{parentName:"p"},"match <expr>"),"."),(0,r.kt)("p",null,"Each branch must be indented and on a new line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"match expr\n    Just m => m\n    12 => a\n    true => b\n    false => c\n    () => d\n    x => e\n    _ => f\n")),(0,r.kt)("h3",{id:"do-notation"},"Do Notation"),(0,r.kt)("p",null,"Newline must be present after ",(0,r.kt)("inlineCode",{parentName:"p"},"do"),"."),(0,r.kt)("p",null,"Each statement in the ",(0,r.kt)("inlineCode",{parentName:"p"},"do")," block must be indented and on a new line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'fn main : unit -> unit\n    () = do\n         println "What is your name?"\n         let name = input ()\n         println ("Hello " + name + "!")\n')),(0,r.kt)("p",null,"The above is equivalent to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'fn main : unit -> unit\n    () = let _ = println "What is your name?" in\n         let name = input () in\n         println ("Hello " + name + "!")\n')),(0,r.kt)("h3",{id:"mdo-notation"},"Mdo Notation"),(0,r.kt)("p",null,"Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"do")," notation, a newline must be present after ",(0,r.kt)("inlineCode",{parentName:"p"},"mdo"),"."),(0,r.kt)("p",null,"Each statement in the ",(0,r.kt)("inlineCode",{parentName:"p"},"mdo")," block must be indented and on a new line."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fn failableOperation : a -> Either Error (Pair a b)\n    a = mdo\n        someFunc a\n        res <- someOtherFunc a\n        pure (Pair a res)\n")),(0,r.kt)("h2",{id:"patterns"},"Patterns"),(0,r.kt)("p",null,"Type constructor patterns, variable patterns, wildcard patterns, and literal patterns."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Maybe::Just a\nMaybe::Just false\nEither::Right ()\nMaybe::Nothing\n\nx\nsomeVar\n\n_\n\n123\n()\ntrue\n'c'\n")),(0,r.kt)("h2",{id:"miscellaneous"},"Miscellaneous"),(0,r.kt)("h3",{id:"imports"},"Imports"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"import a\nimport some.module\nimport control.monad.state\n")),(0,r.kt)("h3",{id:"exports"},"Exports"),(0,r.kt)("p",null,"All exported identifiers must be on the same line, separated by a ",(0,r.kt)("inlineCode",{parentName:"p"},","),"."),(0,r.kt)("p",null,"Exported modules must have their name prefixed by the ",(0,r.kt)("inlineCode",{parentName:"p"},"module")," keyword."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"import m\nimport abc.xyz\n\nexport someDef, fnAbc, module m, Maybe, module abc.xyz\n")),(0,r.kt)("h3",{id:"extern-declarations"},"Extern Declarations"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"extern builtin_add_i32 : i32 -> i32 -> i32\n")))}u.isMDXComponent=!0}}]);